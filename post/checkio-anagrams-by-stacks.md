---
title: "CheckIO - Anagrams By Stacks"
Date: 2013-09-12
tags: [CheckIO, Python]
---

<p><a href="http://www.checkio.org/mission/task/info/anagrams-by-stacks/python-27/"><a href="http://www.checkio.org/mission/task/info/anagrams-by-stacks/python-27/">http://www.checkio.org/mission/task/info/anagrams-by-stacks/python-27/</a></a><br/><br/>这个任务是incinerator的最后一个任务（截至Sep. 13. 2013），题目的要求从配图来看一目了然：<br/><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-FzVxnxW49iM/UjJna7VPzMI/AAAAAAAAD3A/SRjrFNihmsE/s1600/Screen+Shot+2013-09-13+at+9.15.40+AM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="223" src="http://3.bp.blogspot.com/-FzVxnxW49iM/UjJna7VPzMI/AAAAAAAAD3A/SRjrFNihmsE/s320/Screen+Shot+2013-09-13+at+9.15.40+AM.png" width="320"/></a></div>总结下来有这么几点：<br/><br/><ol><li>1，2两个stack是单词长度；</li><li>0固定长度为1</li><li>只能移动最后一个字母（这是废话，要不怎么用stack）</li></ol><br/>我们当然可以设置三个stack，然后递归解决。不过我想了想，既然要求的是——最小步数，而非“成功的达成目标”。那么如果自己写递归还要比较各个方法的优劣的问题，太麻烦了〜如果把最小步数理解成最短路径，这不就变成寻路了吗！而且寻路算法，只要拿出A*就好了啊！<br/>至于A*，我以前题目里面用过的线程的代码可以拿出来：<br/><script src="https://gist.github.com/KenMercusLai/6536509.js"></script><br/>有了这个，我们只需要实现puzzle和node就可以了。而puzzle相当简单：<br/><pre class="prettyprint lang-py">class AnagramsPuzzle(AStar):<br/>    """ description """<br/>    def __init__(self, goal):<br/>        super(AnagramsPuzzle, self).__init__(goal)<br/><br/>    def Heuristic(self, Node):<br/>        return 0<br/><br/>    def getResult(self, Node):<br/>        result = []<br/>        while Node.Parent:<br/>            result.append(Node.Comment)<br/>            Node = Node.Parent<br/>        result.reverse()<br/>        return ','.join(result)</pre>这里需要说到两点：<br/><br/><ol><li>Heuristic在不明确会不会对分析造成影响的前提下，建议直接返回0即可</li><li>Node.Comment是每次移动对应的命令，在Node里面会看到。</li></ol><div>下面就是要实现node了。node最核心的地方就是每个节点可能有那些下一步，虽然重要，但是实现难度并不大。代码如下：</div><pre class="prettyprint lang-py">class AnagramsPuzzleNode(AStarNode):<br/>    """ description """<br/>    def __init__(self, Status, G, Parent):<br/>        super(AnagramsPuzzleNode, self).__init__(Status, G, Parent)<br/><br/>    def PossibleNextNodes(self):<br/>        Result = []<br/>        one_stack = self.Status[0]<br/>        zero_stack = self.Status[1]<br/>        two_stack = self.Status[2]<br/><br/>        if last_char(one_stack)[0] != '':<br/>            # 10<br/>            if last_char(zero_stack)[1] != 0:<br/>                new_one_stack = deepcopy(one_stack)<br/>                new_zero_stack = deepcopy(zero_stack)<br/>                new_zero_stack[0] = last_char(new_one_stack)[0]<br/>                new_one_stack[last_char(new_one_stack)[1]] = ''<br/>                temp = [new_one_stack, new_zero_stack, two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '10'<br/>                Result.append(new_node)<br/>            # 12<br/>            if last_char(two_stack)[1] != len(two_stack)-1:<br/>                new_one_stack = deepcopy(one_stack)<br/>                new_two_stack = deepcopy(two_stack)<br/>                new_one_stack[last_char(one_stack)[1]] = ''<br/>                new_two_stack[two_stack.index('')] = last_char(one_stack)[0]<br/>                temp = [new_one_stack, zero_stack, new_two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '12'<br/>                Result.append(new_node)<br/>        if last_char(zero_stack)[0] != '':<br/>            # 01<br/>            if last_char(one_stack)[1] != len(one_stack)-1:<br/>                new_one_stack = deepcopy(one_stack)<br/>                new_zero_stack = deepcopy(zero_stack)<br/>                new_one_stack[one_stack.index('')] = zero_stack[0]<br/>                new_zero_stack[0] = ''<br/>                temp = [new_one_stack, new_zero_stack, two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '01'<br/>                Result.append(new_node)<br/>            # 02<br/>            if last_char(two_stack)[1] != len(two_stack)-1:<br/>                new_two_stack = deepcopy(two_stack)<br/>                new_zero_stack = deepcopy(zero_stack)<br/>                new_two_stack[two_stack.index('')] = zero_stack[0]<br/>                new_zero_stack[0] = ''<br/>                temp = [one_stack, new_zero_stack, new_two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '02'<br/>                Result.append(new_node)<br/>        if last_char(two_stack)[0] != '':<br/>            # 21<br/>            if last_char(one_stack)[1] != len(one_stack)-1:<br/>                new_two_stack = deepcopy(two_stack)<br/>                new_one_stack = deepcopy(one_stack)<br/>                new_one_stack[new_one_stack.index('')] = last_char(new_two_stack)[0]<br/>                new_two_stack[last_char(new_two_stack)[1]] = ''<br/><br/>                temp = [new_one_stack, zero_stack, new_two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '21'<br/>                Result.append(new_node)<br/>            # 20<br/>            if last_char(zero_stack)[1] != 0:<br/>                new_two_stack = deepcopy(two_stack)<br/>                new_zero_stack = deepcopy(zero_stack)<br/>                new_two_stack[last_char(two_stack)[1]] = ''<br/>                new_zero_stack[0] = last_char(two_stack)[0]<br/>                temp = [new_one_stack, zero_stack, new_two_stack]<br/>                new_node = AnagramsPuzzleNode(temp, self.G + 1, self)<br/>                new_node.Comment = '20'<br/>                Result.append(new_node)<br/>        return Result</pre>请先不要吐槽这个丑陋的代码，确定有简化的写法来实现，不过在说tricky方法之前，这个无非是最直观的代码了。把实现和优化分开还是比较简单的。<br/><br/>有了以上的代码，我们剩下的就是定义开始和结束状态，然后默默的等结果就行啦<br/><pre class="prettyprint lang-py">def checkio(data):<br/>    """ description """<br/>    start_position, end_position = data.split('-')<br/>    start_position = [list(start_position), [''], ['']*len(list(start_position))]<br/>    end_position = [['']*len(list(end_position)), [''], list(end_position)]<br/>    puzzle = AnagramsPuzzle(end_position)<br/>    start_node = AnagramsPuzzleNode(start_position, 0, None)<br/>    return puzzle.search(start_node)</pre><br/>好啦，综合起来，完整的代码如下：<br/><script src="https://gist.github.com/KenMercusLai/6545941.js"></script><br/>说起来我要吐槽一下，这个代码的check实在太慢了——20多分钟一次完整的check，完成check后如果publish，他又要在check一次……</p>